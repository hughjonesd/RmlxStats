% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mlxs-lm.R
\name{mlxs_lm_fit}
\alias{mlxs_lm_fit}
\title{Fit an MLX linear model from design matrices}
\usage{
mlxs_lm_fit(x, y, weights = NULL)
}
\arguments{
\item{x}{MLX design matrix (or object coercible via \code{\link[Rmlx:as_mlx]{Rmlx::as_mlx()}}) whose
rows represent observations and columns represent predictors.}

\item{y}{MLX column vector (or object coercible via \code{\link[Rmlx:as_mlx]{Rmlx::as_mlx()}}) holding
the response values.}

\item{weights}{Optional MLX column vector or numeric vector of non-negative
observation weights. When supplied, weighted least squares are fit via the
standard square-root weighting.}
}
\value{
A list with components \code{coefficients}, \code{fitted.values}, \code{residuals},
\code{effects}, and \code{qr}, mirroring the corresponding pieces of \code{\link[stats:lm]{stats::lm()}}.
Array-valued components remain MLX matrices to keep downstream GPU
pipelines in device memory.
}
\description{
\code{mlxs_lm_fit()} powers \code{\link[=mlxs_lm]{mlxs_lm()}} by wrapping the QR-based solver that runs
entirely on MLX arrays.
}
\details{
Inputs that are not already MLX objects are converted with
\code{\link[Rmlx:as_mlx]{Rmlx::as_mlx()}} or \code{\link[Rmlx:mlx_matrix]{Rmlx::mlx_matrix()}} so callers can provide base-R
matrices or vectors. Weighted fits are performed by applying the standard
square-root weight transform before solving the QR system.
}
\examples{
x <- Rmlx::as_mlx(cbind(1, as.matrix(mtcars[c("cyl", "disp")])))
y <- Rmlx::mlx_matrix(mtcars$mpg, ncol = 1)
fit <- mlxs_lm_fit(x, y)
drop(as.matrix(fit$coefficients))

}
