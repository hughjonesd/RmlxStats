---
title: "Benchmarking MLX-backed Linear and Generalized Linear Models"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Benchmarking MLX-backed Linear and Generalized Linear Models}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)


library(RmlxStats)
library(Rmlx)
library(nycflights13)
library(bench)
library(fixest)
library(RcppEigen)
library(speedglm)
library(fastglm)
library(ggplot2)
library(tidyr)
library(ggbeeswarm)
```

The `mlxs_lm()` and `mlxs_glm()` functions mirror `stats::lm()` and
`stats::glm()` but execute their linear algebra with the MLX backend.
This vignette benchmarks these implementations against standard R
functions and specialized fast fitting packages (fixest, RcppEigen,
speedglm, fastglm) using the sizeable `nycflights13::flights` dataset,
demonstrating the performance gains available when Metal acceleration
is active.

## Data Preparation

We retain a handful of numeric predictors from the flights data and
drop rows with missing values in the variables of interest.

```{r data-prep}
flights <- as.data.frame(nycflights13::flights)
vars <- c("arr_delay", "dep_delay", "air_time", "distance")
complete_rows <- complete.cases(flights[, vars])
bench_data <- flights[complete_rows, vars]
nrow(bench_data)
```

The resulting dataset contains hundreds of thousands of observations,
large enough to expose performance differences in the solvers.

## Benchmark Setup

We benchmark several linear model solvers that accept formula interfaces.
The `bench` package automates warm-up and repetition.

```{r timings, cache=FALSE}
lm_formula <- arr_delay ~ dep_delay + air_time + distance

bench_mark <- mark(
  lm = lm(lm_formula, data = bench_data),
  mlxs_lm = mlxs_lm(lm_formula, data = bench_data),
  feols = feols(lm_formula, data = bench_data),
  fastLm = RcppEigen::fastLm(lm_formula, data = bench_data),
  speedlm = speedglm::speedlm(lm_formula, data = bench_data),
  iterations = 5,
  check = FALSE
)

# Summarize median timings, memory allocation, and relative speed.
bench_summary <- data.frame(
  method = as.character(bench_mark$expression),
  median_sec = as.numeric(bench_mark$median, units = "s"),
  mem_mb = as.numeric(bench_mark$mem_alloc, units = "MB"),
  itr_per_sec = bench_mark$`itr/sec`
)
bench_summary$relative <- bench_summary$median_sec / min(bench_summary$median_sec)
bench_summary
ggplot2::autoplot(bench_mark, type = "boxplot")
```

The benchmark table reports the median execution time (seconds), memory
allocation (megabytes), iteration rate, and relative speed for each method
across five iterations. The `relative` column expresses how many times slower
each method is compared to the fastest option (values close to 1 indicate the
winner).

## Agreement on Flights Benchmark

Confirm that each solver matches the reference solution within floating
point tolerance.

```{r agreement}
lm_fit <- lm(lm_formula, data = bench_data)
mlxs_fit <- mlxs_lm(lm_formula, data = bench_data)
feols_fit <- feols(lm_formula, data = bench_data)
fastlm_fit <- RcppEigen::fastLm(lm_formula, data = bench_data)
speedlm_fit <- speedglm::speedlm(lm_formula, data = bench_data)

coef_delta <- max(abs(coef(lm_fit) - mlxs_fit$coefficients))
fitted_delta <- max(abs(fitted(lm_fit) - mlxs_fit$fitted.values))

feols_coef_delta <- max(abs(coef(lm_fit) - coef(feols_fit)))
feols_fitted_delta <- max(abs(fitted(lm_fit) - as.vector(predict(feols_fit))))

fastlm_coef_delta <- max(abs(coef(lm_fit) - fastlm_fit$coefficients))
fastlm_fitted_delta <- max(abs(fitted(lm_fit) - fastlm_fit$fitted.values))

speedlm_coef_delta <- max(abs(coef(lm_fit) - speedlm_fit$coefficients))
speedlm_fitted_delta <- max(abs(fitted(lm_fit) - as.vector(predict(speedlm_fit))))

c(
  max_coefficient_difference = coef_delta,
  max_fitted_difference = fitted_delta,
  feols_max_coefficient_difference = feols_coef_delta,
  feols_max_fitted_difference = feols_fitted_delta,
  fastlm_max_coefficient_difference = fastlm_coef_delta,
  fastlm_max_fitted_difference = fastlm_fitted_delta,
  speedlm_max_coefficient_difference = speedlm_coef_delta,
  speedlm_max_fitted_difference = speedlm_fitted_delta
)
```

Differences remain on the order of numerical precision, confirming
that `mlxs_lm()` and the other high-performance solvers reproduce the
reference solution while offering faster runtimes.

## High-Dimensional Benchmark

To stress-test performance when both sample size and feature count are large,
we simulate a design matrix with many rows and columns.

```{r highp-data}
set.seed(20251031)
n_hd <- 10000
p_hd <- 400
x_hd <- matrix(rnorm(n_hd * p_hd), nrow = n_hd, ncol = p_hd)
colnames(x_hd) <- paste0("x", seq_len(p_hd))
beta_true <- runif(p_hd, -1, 1)
y_hd <- drop(x_hd %*% beta_true + rnorm(n_hd, sd = 0.5))
hd_data <- data.frame(y = y_hd, x_hd)

options(expressions = 15000) # to avoid errors due to nested evaluation
hd_formula <- DF2formula(hd_data)
```

```{r highp-benchmark, cache=FALSE}
hd_mark <- mark(
  lm = lm(hd_formula, data = hd_data),
  mlxs_lm = mlxs_lm(hd_formula, data = hd_data),
  feols = feols(hd_formula, data = hd_data),
  fastLm = RcppEigen::fastLm(hd_formula, data = hd_data),
  speedlm = speedglm::speedlm(hd_formula, data = hd_data),
  iterations = 3,
  check = FALSE
)

hd_summary <- data.frame(
  method = as.character(hd_mark$expression),
  median_sec = as.numeric(hd_mark$median, units = "s"),
  mem_mb = as.numeric(hd_mark$mem_alloc, units = "MB"),
  itr_per_sec = hd_mark$`itr/sec`
)
hd_summary$relative <- hd_summary$median_sec / min(hd_summary$median_sec)
hd_summary
ggplot2::autoplot(hd_mark, type = "beeswarm")
```

## Agreement on the Simulated Problem

Even in the high-dimensional setting, the MLX-backed fit lines up with the
reference linear model.

```{r highp-agreement}
lm_hd <- lm(hd_formula, data = hd_data)
mlxs_hd <- mlxs_lm(hd_formula, data = hd_data)
speedlm_hd <- speedglm::speedlm(hd_formula, data = hd_data)

c(
  max(abs(coef(lm_hd) - mlxs_hd$coefficients)),
  max(abs(coef(lm_hd) - speedlm_hd$coefficients))
)
```

The largest coefficient difference stays at floating-point noise levels,
confirming that the accelerated solver preserves numerical accuracy while
scaling gracefully with both observations and predictors.

## GLM Benchmark: Logistic Regression

The `mlxs_glm()` function extends the MLX backend to generalized linear models.
We benchmark it against `stats::glm()` and `speedglm::speedglm()` using a
binomial family on the flights data.

```{r glm-data-prep}
# Create binary outcome: whether arrival delay exceeds 15 minutes
bench_data$late <- as.integer(bench_data$arr_delay > 15)
glm_formula <- late ~ dep_delay + air_time + distance
```

```{r glm-timings, cache=FALSE}
glm_mark <- mark(
  glm = glm(glm_formula, family = binomial(), data = bench_data),
  mlxs_glm = mlxs_glm(glm_formula, family = mlxs_binomial(), data = bench_data),
  speedglm = speedglm::speedglm(glm_formula, family = binomial(), data = bench_data),
  iterations = 5,
  check = FALSE
)

glm_summary <- data.frame(
  method = as.character(glm_mark$expression),
  median_sec = as.numeric(glm_mark$median, units = "s"),
  mem_mb = as.numeric(glm_mark$mem_alloc, units = "MB"),
  itr_per_sec = glm_mark$`itr/sec`
)
glm_summary$relative <- glm_summary$median_sec / min(glm_summary$median_sec)
glm_summary
ggplot2::autoplot(glm_mark, type = "boxplot")
```

## Agreement on GLM Benchmark

Check that the MLX-backed GLM matches the reference implementation:

```{r glm-agreement}
glm_fit <- glm(glm_formula, family = binomial(), data = bench_data)
mlxs_glm_fit <- mlxs_glm(glm_formula, family = binomial(), data = bench_data)
speedglm_fit <- speedglm::speedglm(glm_formula, family = binomial(), data = bench_data)

glm_coef_delta <- max(abs(coef(glm_fit) - mlxs_glm_fit$coefficients))
glm_fitted_delta <- max(abs(fitted(glm_fit) - mlxs_glm_fit$fitted.values))
speedglm_coef_delta <- max(abs(coef(glm_fit) - speedglm_fit$coefficients))
speedglm_fitted_delta <- max(abs(fitted(glm_fit) - as.vector(predict(speedglm_fit))))

c(
  mlxs_max_coefficient_difference = glm_coef_delta,
  mlxs_max_fitted_difference = glm_fitted_delta,
  speedglm_max_coefficient_difference = speedglm_coef_delta,
  speedglm_max_fitted_difference = speedglm_fitted_delta
)
```

All implementations agree within numerical tolerance, confirming that `mlxs_glm()`
produces accurate results for generalized linear models.

## Other Fast Linear Modeling Options

Beyond the methods benchmarked here, practitioners often turn to
`biglm::biglm()` for streamed data that do not fit in memory or
`glmnet` for elastic-net regularisation. Packages such as `MatrixModels`
and `SparseM` also provide optimized pathways for sparse design matrices.
